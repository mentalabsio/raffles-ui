/** @jsxImportSource theme-ui */
import Head from "next/head"

import { Button, Flex, Heading, Text } from "@theme-ui/components"

import Header from "@/components/Header/Header"
import { useWallet } from "@solana/wallet-adapter-react"
import { useRafflesStore } from "@/hooks/useRafflesStore"
import { useCallback, useEffect, useMemo, useState } from "react"
import { Raffle } from "lib/types"
import Link from "next/link"
import { getDisplayAmount } from "lib/accounts"
import Countdown from "react-countdown"
import { ClockIcon, CoinIcon, TicketIcon } from "@/components/icons"
import { PurchaseTickets } from "@/components/PurchaseTicket"
import { useRouter } from "next/router"
import { LoadingIcon } from "@/components/icons/LoadingIcon"
import { useProgramApis } from "@/hooks/useProgramApis"
import { expand } from "lib/randomnessTools"
import ClaimButton from "@/components/ClaimButton"
import { claimPrize } from "lib/actions/claimPrize"
import { sleep } from "lib/utils"
import confetti from "canvas-confetti"

const makeConfetti = () => {
  const duration = 5 * 1000
  const animationEnd = Date.now() + duration
  const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 }

  function randomInRange(min: number, max: number) {
    return Math.random() * (max - min) + min
  }

  let intervalId: ReturnType<typeof setInterval>
  intervalId = setInterval(() => {
    const timeLeft = animationEnd - Date.now()

    if (timeLeft <= 0) {
      return clearInterval(intervalId)
    }

    var particleCount = 50 * (timeLeft / duration)
    // since particles fall down, start a bit higher than random
    confetti(
      Object.assign({}, defaults, {
        particleCount,
        origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 },
      })
    )
    confetti(
      Object.assign({}, defaults, {
        particleCount,
        origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 },
      })
    )
  }, 250)

  return intervalId
}

export default function Home() {
  const { publicKey } = useWallet()
  const { raffles, fetchAllRaffles, fetching, updateRaffleById } =
    useRafflesStore()
  const { draffleClient } = useProgramApis()

  const { query } = useRouter()

  useEffect(() => {
    fetchAllRaffles()
  }, [fetchAllRaffles])

  const currentRaffle = useMemo(
    () => raffles && raffles.get(query.id.toString()),
    [raffles, query]
  )

  const MAX_TITLE_LENGTH = 20

  const ended = new Date() > currentRaffle?.endTimestamp

  console.log(currentRaffle)

  /** CLAIM */
  const entrant = useMemo(() => {
    if (!draffleClient.provider.wallet.publicKey) return

    return currentRaffle?.entrants.get(
      draffleClient.provider.wallet.publicKey.toString()
    )
  }, [currentRaffle, draffleClient.provider.wallet.publicKey]) // "Unnecessary" dependency required due to React not picking up change in publicKey subfield

  // Each winning ticket index for each prize
  const winningTickets = useMemo(() => {
    if (
      !currentRaffle?.randomness ||
      !currentRaffle?.entrants ||
      currentRaffle?.entrants.size === 0
    )
      return []
    const secret = currentRaffle?.randomness
    return currentRaffle?.prizes.map((_, prizeIndex) => {
      const rand = expand(secret, prizeIndex)
      return rand % currentRaffle?.totalTickets
    })
  }, [currentRaffle])

  const entrantWinningTickets = useMemo(() => {
    if (!entrant || !winningTickets) return []
    return winningTickets.reduce<{ prizeIndex: number; ticketIndex: number }[]>(
      (acc, ticketIndex, prizeIndex) => {
        if (entrant?.tickets.includes(ticketIndex)) {
          return [...acc, { prizeIndex, ticketIndex }]
        } else {
          return acc
        }
      },
      []
    )
  }, [entrant, winningTickets])

  useEffect(() => {
    if (entrantWinningTickets.length === 0) return
    const confettiTimerId = makeConfetti()
    return () => clearInterval(confettiTimerId)
  }, [entrantWinningTickets.length])

  const onClaimPrize = useCallback(
    async (prizeIndex: number, ticketIndex: number) => {
      try {
        await claimPrize(draffleClient, currentRaffle, prizeIndex, ticketIndex)
        await sleep(500)
        updateRaffleById(currentRaffle.publicKey.toString())
        // toast.success('Prize claimed, check your wallet!');
      } catch (error: any) {
        if (error.msg) {
          // toast.error(`Transaction failed: ${error.msg}`);
        } else {
          // toast.error('Unexpected error');
        }
      }
    },
    [draffleClient, currentRaffle, updateRaffleById]
  )

  const winnersRevealed = useMemo(
    () => !!currentRaffle?.randomness,
    [currentRaffle]
  )

  const userHasParticipated = useMemo(
    () => (entrant?.tickets.length || 0) > 0,
    [entrant]
  )

  return (
    <>
      <Head>
        <title>Raffles</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Header />
      <main
        sx={{
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          marginTop: "4rem",
        }}
      >
        <Heading mb=".8rem" variant="heading1">
          {query.id}
        </Heading>

        <Flex
          sx={{
            gap: "1.6rem",
            marginTop: "3.2rem",
            flexDirection: "column",
          }}
        >
          {currentRaffle ? (
            <>
              <Flex
                sx={{
                  flexDirection: "column",
                  borderColor: "primary",
                  borderRadius: ".4rem",
                  padding: "1.6rem",
                  alignItems: "center",
                  gap: "1.6rem",
                }}
              >
                <Heading variant="heading3">
                  {currentRaffle.metadata.name.length > MAX_TITLE_LENGTH ? (
                    <>
                      {currentRaffle.metadata.name.slice(
                        0,
                        MAX_TITLE_LENGTH - 4
                      )}{" "}
                      ...
                    </>
                  ) : (
                    currentRaffle.publicKey.toString().slice(0, 9)
                  )}
                  ...
                </Heading>

                <span>
                  {currentRaffle.prizes.length} prize
                  {currentRaffle.prizes.length > 1 && "s"}
                </span>

                {publicKey && entrantWinningTickets.length > 0 ? (
                  <Text variant="h3">
                    Hurray, you won! Claim your prizes below:
                  </Text>
                ) : null}

                {currentRaffle.prizes.map((prize, prizeIndex) => {
                  const ticketIndex = winningTickets[prizeIndex]
                  const isWon = entrantWinningTickets.some(
                    (entrantWinningTicket) =>
                      entrantWinningTicket.ticketIndex === ticketIndex
                  )

                  const imageUrl = prize?.meta.imageUri

                  return (
                    <>
                      <img
                        sx={{
                          maxWidth: "8rem",
                        }}
                        src={imageUrl}
                      />
                      {isWon && (
                        <ClaimButton
                          claimPrize={onClaimPrize}
                          prize={prize}
                          prizeIndex={prizeIndex}
                          ticketIndex={ticketIndex}
                        />
                      )}
                    </>
                  )
                })}

                <Text
                  sx={{
                    display: "flex",
                    gap: ".8rem",
                    alignItems: "center",
                  }}
                >
                  <ClockIcon />

                  {!ended ? (
                    <Countdown date={currentRaffle.endTimestamp} />
                  ) : (
                    "Ended"
                  )}
                </Text>
                <Flex
                  sx={{
                    gap: "3.2rem",
                  }}
                >
                  <Text
                    sx={{
                      display: "flex",
                      gap: ".8rem",
                      alignItems: "center",
                    }}
                  >
                    <TicketIcon />
                    {currentRaffle.totalTickets} sold
                  </Text>

                  <Flex
                    sx={{
                      gap: ".8rem",
                      alignItems: "center",
                    }}
                  >
                    <CoinIcon />
                    {getDisplayAmount(
                      currentRaffle.proceeds.ticketPrice,
                      currentRaffle.proceeds.mint
                    )}{" "}
                    ${currentRaffle.proceeds.mint.symbol} ea
                  </Flex>
                </Flex>
                {winnersRevealed ? (
                  <Text>Winners have been announced!</Text>
                ) : (
                  <Text>Winners have NOT been announced yet!</Text>
                )}
              </Flex>
              {!ended && (
                <PurchaseTickets
                  raffle={currentRaffle}
                  updateRaffle={() =>
                    updateRaffleById(currentRaffle.publicKey.toString())
                  }
                />
              )}
              {/** CLAIM */}
              {!publicKey ? (
                <Text>
                  Connect your wallet to check if you have won any prizes!
                </Text>
              ) : null}

              {publicKey && !userHasParticipated ? (
                <Text>
                  Uh oh! It looks like you did not participate in this raffle!
                </Text>
              ) : null}

              {publicKey &&
              userHasParticipated &&
              entrantWinningTickets.length === 0 ? (
                <>
                  <Text variant="h3">Oh no! No prize.</Text>
                  <Text variant="body1">Better luck next time!</Text>
                </>
              ) : null}
            </>
          ) : (
            <LoadingIcon />
          )}
        </Flex>
      </main>

      <footer
        sx={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          margin: "4rem 0",
        }}
      >
        Powered by
        <a
          href="https://twitter.com/mentaworks"
          target="_blank"
          rel="noopener noreferrer"
          sx={{
            display: "flex",
            alignItems: "center",
            marginLeft: "0.2em",
          }}
        >
          <Text
            variant="small"
            sx={{
              display: "flex",
              alignItems: "center",
            }}
          >
            menta.works
          </Text>
        </a>
      </footer>
    </>
  )
}
